const fs = require("fs");
const Converter = require('pdftohtmljs');
const inlineCSS = require('inline-css');
const {JSDOM} = require("jsdom");
const {interpret} = require('xstate');
const {leftMap} = require("./structure");

var path = require('path');

if (process.argv.length < 3) {
    console.log("please provide a valid pdf path");
    process.exit(1);
}

let input = process.argv[2];

let outputPath = 'output';
let outputFile = 'raw.html';

// check if OS is Win, to use *.bat, else *.sh
let bin = process.platform.toLowerCase() === 'win32' ? '.\\pdf2htmlEX.bat' : path.resolve('.') + '/pdf2htmlEX.sh';

let pdf = Converter(input, outputFile, {
    bin,
});

// for testing only parse page 187 and 188
pdf.add_options([
    "--dest-dir " + outputPath,
    "--fit-width 968",
    "-f 49",
    "-l 191",
    "--optimize-text 5",
    "--printing 0",
    //"--embed-css 0",
    //"--embed-font 0",
    //"--embed-javascript 0",
]);

pdf.convert().then(function () {
    console.log("Generated raw html output [" + outputPath + "/" + outputFile + "]");
    console.log("Loading generated html.");

    return new Promise(function (resolve, reject) {
        fs.readFile(outputPath + "/" + outputFile, function (err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data.toString());
            }
        });
    });
}).then(function (html) {
    // Remove styles generated by pdf2htmlEX because they use invalid CSS syntax and cause inlineCSS to fail.
    console.log("Cleaning up generated html output");

    return html
        .replace('<link rel="stylesheet" href="base.min.css"/>', '')
        .replace('<link rel="stylesheet" href="fancy.min.css"/>', '')
        .replace('<link rel="stylesheet" href="document.css"/>', '<link rel="stylesheet" href="' + outputPath + '/document.css"/>')
        .replace('<div id="sidebar">\n<div id="outline">\n</div>\n</div>\n', '')
        .replace('<div class="pi" data-data=\'{"ctm":[1.330000,0.000000,0.000000,1.330000,0.000000,0.000000]}\'></div>', '');
}).then(function (html) {
    console.log("Converting pdf2htmlEX generated css to inline css");

    return new Promise(function (resolve) {
        inlineCSS(html, {url: ' '}).then(function (html) {
            fs.writeFile('output/inline.html', html, function () {
                resolve(html);
            });
        });
    });
}).then(function (html) {
    console.log("Parsing generated html data");

    return new JSDOM(html).window.document;
}).then(function (document) {
    console.log("Analysing document");
    console.log("");

    const {leftMap, keyWords} = require('./structure');

    // Available variables:
    // - Machine
    // - interpret
    // - assign
    // - send
    // - sendParent
    // - spawn
    // - raise
    // - actions
    // - XState (all XState exports)

    const fetchMachine = require('./machine');

    let chapters, chapter, letter, paragraph;

    const fetchService = interpret(fetchMachine).onTransition(state => {
        switch (state.value) {
            case "start":
                chapters = [];
                break;
            case "chapter":
                if (letter) {
                    chapter.letters.push(letter);
                    letter = null;
                }

                if (chapter) {
                    chapters.push(chapter);
                }

                chapter = newChapter(state.context.chapter);
                break;

            case "title":
                if (letter) {
                    chapter.letters.push(letter);
                }

                letter = newLetter(state.context.letter);
                break;

            case "end":
                if (chapter) {
                    if (letter) {
                        chapter.letters.push(letter);
                    }

                    chapters.push(chapter);
                }
                break;
        }
    }).start();

    // fake new chapter
    // fetchService.send('CHAPTER');

    // TODO:
    // use state machine (?)
    //  - current chapter
    //  - current letter
    //  - position inside letter (date, title, paragraph, apparatus, ...)
    //  - parse next line in document and decide based on current position

    // find chapters
    // find start/title of letter
    // extract paragraphs and line breaks
    // drop line numbers
    // skip apparatuses and comments
    // processes next letter

    function checkLine(line) {
        let lineType = type(line, leftMap);
        let lineFont = font(line);

        switch (fetchService.getSnapshot().value) {
            case "chapter":
            case "comments":
                if (lineFont === 'bold' && lineType === 'line') {
                    fetchService.send('TITLE');
                }
                break;
            case "title":
                fetchService.send('BODY');
                break;
            case "body":
                if (keyWords.apparatuses.some((keyWord) => line.textContent.includes(keyWord))) {
                    fetchService.send('APPARATUSES');
                }
                break;
            case 'apparatuses':
                if (keyWords.comments.some((keyWord) => line.textContent.includes(keyWord))) {
                    fetchService.send('COMMENTS');
                }
                break;
        }
    }

    let pages = document.querySelectorAll('body > div#page-container > div > div');

    // loop over all pages an lines
    pages.forEach(function (page) {

        if (isNewChapter(page)) {
            fetchService.send('CHAPTER');
            return;
        }

        // console.log('');
        // console.log('=========== new page ===========');

        page.childNodes.forEach(function (line, index) {
            if (index < 2) { //TODO: is this always right?
                // console.log('page header or number');
            } else {
                // detect state change
                checkLine(line);

                const type = fetchService.getSnapshot().value.toString();

                if (letter && letter.hasOwnProperty(type)) {
                    letter[type].push(line);
                }
            }
        });
    });

    fetchService.send('END');

    return chapters;
}).then(function (chapters) {
    console.log("Generating xml");

    function format(node) {
        let nodeXml = '';

        let spacerMode = false;

        if (parseFloat(node.style.wordSpacing) > 1000) {
            spacerMode = true;
            //console.log("enable alternate indentation mode");

            nodeXml += '<hi redention="#et10">';
        }

        node.childNodes.forEach((node) => {
            switch (node.nodeType) {
                case 3:
                    if (node.textContent.trim() !== '') {
                        nodeXml += node.textContent;
                    }
                    break;

                default:
                    // recursive
                    if (font(node) === 'bold') {
                        nodeXml += '<hi redention="#f">' + format(node) + '</hi>';
                    } else if (font(node) === 'italic') {
                        nodeXml += '<hi redention="#i">' + format(node) + '</hi>';
                    } else if (spacerMode && parseFloat(node.style.marginLeft) < -1000) {
                        //console.log("nice");
                    } else if (parseFloat(node.style.width) > 1000) {
                        //console.log("more spacing technics");
                        if (nodeXml.trim() === '') {
                            nodeXml += '<hi redention="#et10">' + format(node);
                            spacerMode = true;
                        }
                    } else {
                        // TODO: set "letter needs attention" flag
                        nodeXml += '<hi redention="#unknown">' + format(node) + '</hi>';
                    }
            }
        });

        if (spacerMode) {
            nodeXml += '</hi>';
        }

        return nodeXml;
    }

    function processLine(line) {
        let lineXml = '';

        let lineType = type(line, leftMap);
        if (lineType === 'new-paragraph') {
            lineXml += "</p>\n\n<p>\n";

            lineXml += "<lb>" + format(line) + "</lb>\n";
        } else if (lineType === 'line') {
            lineXml += "<lb>" + format(line) + "</lb>\n";
        } else if (lineType === 'line-number') {
            // skip line numbers
        } else {
            // unknown line indent -> probably right aligned text
            // does not detect indented text with left alignment
            // TODO: find best indentation
            lineXml += `<lb><hi redention="#right">${line.textContent}</hi></lb>\n`;
        }

        return lineXml;
    }

    // TODO: generate xml for letters
    chapters.forEach(function (chapter) {
        console.log("chapter: " + chapter.number);
        chapter.letters.forEach((letter) => {
            //console.log("\n");

            console.log("Letter: " + letter.number);

            //console.log("\n");

            // 1. letter.title to xml
            const titleXml = letter.title.map((node) => {
                return node.textContent.trim();
            }).join(' ');

            console.log(titleXml);

            // 2. letter.body to xml
            let bodyXml = '<p>\n';

            letter.body.forEach((line) => {
                bodyXml += processLine(line);
            });

            bodyXml += "</p>";

            letter.xml = `<letter><title>${titleXml}</title><body>${bodyXml}</body></letter>`;

            // console.log(letter.xml);

            // 3. clean up apparatuses
            // 4. clean up comments
        });
    });
}).catch(function (err) {
    console.log(err);
});

function isNewChapter(page) {
    // check if always correct "< 10"
    if (page.childNodes.length < 10) {
        return page.textContent.toLowerCase().includes("briefwechsel");
    }

    return false;
}

function newChapter(number) {
    return {
        number,
        letters: [],
    };
}

function newLetter(number) {
    return {
        number,
        title: [],
        body: [],
        apparatuses: [],
        comments: [],
        xml: ''
    };
}

function type(line, leftMap) {
    let left = Math.round(parseFloat(line.style.left));

    return leftMap[left];
}

function font(node) {
    if (!node.classList) {
        return 'normal';
    }

    if (node.classList.contains('ff1')) {
        return 'italic';
    }

    if (node.classList.contains('ff3')) {
        return 'bold';
    }

    return 'normal';
}
