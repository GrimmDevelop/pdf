import {Machine, interpret} from 'xState';
const fs = require("fs");
const Converter = require('pdftohtmljs');
const inlineCSS = require('inline-css');
const jsdom = require("jsdom");
const {JSDOM} = jsdom;

if (process.argv.length < 3) {
    console.log("please provide a valid pdf path");
    process.exit(1);
}

let input = process.argv[2];

let path = 'output';
let outputFile = 'raw.html';

// check if OS is Win, to use *.bat, else *.sh
let bin = process.platform.toUpperCase().indexOf('WIN')>=0 ? '.\\pdf2htmlEX.bat' : '.\\pdf2htmlEX.sh';

let pdf = Converter(input, outputFile, {
    bin,
});

// for testing only parse page 187 and 188
pdf.add_options([
    "--dest-dir " + path,
    "--fit-width 968",
    "-f 187",
    "-l 188",
    "--optimize-text 5",
    "--printing 0",
    //"--embed-css 0",
    //"--embed-font 0",
    //"--embed-javascript 0",
]);

pdf.convert().then(function () {
    console.log("Generated raw html output [" + path + "/" + outputFile + "]");
    console.log("Loading generated html.");

    return new Promise(function (resolve, reject) {
        fs.readFile(path + "/" + outputFile, function (err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data.toString());
            }
        });
    });
}).then(function (html) {
    // Remove styles generated by pdf2htmlEX because they use invalid CSS syntax and cause inlineCSS to fail.
    console.log("Cleaning up generated html output");

    return html
        .replace('<link rel="stylesheet" href="base.min.css"/>', '')
        .replace('<link rel="stylesheet" href="fancy.min.css"/>', '')
        .replace('<link rel="stylesheet" href="document.css"/>', '<link rel="stylesheet" href="' + path + '/document.css"/>')
        .replace('<div id="sidebar">\n<div id="outline">\n</div>\n</div>\n', '')
        .replace('<div class="pi" data-data=\'{"ctm":[1.330000,0.000000,0.000000,1.330000,0.000000,0.000000]}\'></div>', '');
}).then(function (html) {
    console.log("Converting pdf2htmlEX generated css to inline css");

    return new Promise(function (resolve) {
        inlineCSS(html, { url: ' '}).then(function (html) {
            fs.writeFile('output/inline.html', html, function() {
                resolve(html);
            });
        });
    });
}).then(function (html) {
    console.log("Parsing generated html data");

    return new JSDOM(html).window.document;
}).then(function (document) {
    console.log("Analysing document");
    console.log("");

    let pages = document.querySelectorAll('body > div#page-container > div > div');

    let leftMap = {
        94: 'line-number',      // lno 10 or greater
        101: 'line-number',     // lno 5
        132: 'line',            // normal line indent
        155: 'new-paragraph',   // new paragraphs have a greater indent
    };

    // Available variables:
  // - Machine
  // - interpret
  // - assign
  // - send
  // - sendParent
  // - spawn
  // - raise
  // - actions
  // - XState (all XState exports)
  
  const fetchMachine = Machine({
    id: 'letters',
    initial: 'start',
    context: {
      chapter: 0,
      letter: 0
    },
    states: {
      start: {
        on: {
          CHAPTER: {
            target: 'chapter',
            actions: assign({
              chapter: (context, event) => context.chapter + 1
            })
          }
        }
      },
      chapter: {
        on: {
          TITLE: {
            target: 'title',
            actions: assign({
              letter: (context, event) => 1
            })
          }
        }
      },
      title: {
        on: {
          BODY: 'body'
        }
      },
      body: {
        on: {
          APPARATUSES: 'apparatuses'
        }
      },
      apparatuses: {
        on: {
          COMMENTS: 'comments'
        }
      },
      comments: {
        on: {
          TITLE: {
            target: 'title',
            actions: assign({
              letter: (context, event) => context.letter + 1
            })
          },
          CHAPTER: {
            target: 'chapter',
            actions: assign({
              chapter: (context, event) => context.chapter + 1,
              letter: (context, event) => 1
            })
          },
          END: 'end'
        }
      },
      end: {
        type: 'final'
      }
    }
  });

  const fetchService = interpret(fetchMachine).onTransition(state => console.log(state.value));
    // TODO:
    // use state machine (?)
    //  - current chapter
    //  - current letter
    //  - position inside letter (date, title, paragraph, apparatus, ...)
    //  - parse next line in document and decide based on current position

    // find chapters
    // find start/title of letter
    // extract paragraphs and line breaks
    // drop line numbers
    // skip apparatuses and comments
    // processes next letter

    let letters = [];

    let letter, paragraph;

    fetchService.start();

    pages.forEach(function (page) {
        page.childNodes.forEach(function (line, index)) {
            switch (fetchMachine.state.value) {
                case start:
                    // do nothing until chapter starts
                    if (/*detection if chapter starts*/) {fetchService.send('CHAPTER');}
                    break;
                case chapter:
                    // get chapter name and id and search for letter start. ignore introductory text
                    // when letter title is found start new letter
                    if (bold && lineType === 'line') {
                        fetchService.send('TITLE');
                        if (letter) {
                            letters.push(letter);
                         }

                        letter = {
                        title: line.textContent,
                        paragraphs: [],
                        apparatuses: null,
                        comments: null,
                        };
                        paragraph = [];
                    }
                    break;
                case title:
                    // new letter was already created

                    break;
                case body:

                    break;
                case apparatuses:

                    break;
                case comments:

                    break;
                case end:

                    break;
            }
        }
    })



    pages.forEach(function (page) {
        page.childNodes.forEach(function (line, index) {
            if (index === 0) {
                console.log('');
                console.log('=========== new page ===========');
            }

            if (index < 2) {
                console.log('page header or number');
            }

            let left = Math.round(parseFloat(line.style.left));

            let lineType = leftMap[left];

            let normal = line.classList.contains('ff2');
            let italic = line.classList.contains('ff1');
            let bold = line.classList.contains('ff3');

            if (!(bold && lineType === 'line') && !letter) {
                return;
            }

            if (bold && lineType === 'line') {
                // letter title -> create new letter object
                console.log(line.textContent);
                if (letter) {
                    letters.push(letter);
                }

                letter = {
                    title: line.textContent,
                    paragraphs: [],
                    apparatuses: null,
                    comments: null,
                };

                paragraph = [];
            } else if (lineType === 'new-paragraph') {
                if (paragraph.length > 0) {
                    letter.paragraphs.push(paragraph);
                }

                paragraph = [];

                paragraph.push(line.textContent);
                console.log(line.textContent);
            } else if ((line.textContent.includes('Empfängertext:') || line.textContent.includes('Datierung:') ||
                        line.textContent.includes('Überlieferung:')) && lineType === 'line') {
                // apparatuses
                // will always start with one of those words.
                // statemaschiene should ignore everithing until the next letter starts
            } else if (line.textContent.includes('Sachkommentar:') && lineType === 'line') {
                // comments
                // will always start with this word.
                // statemaschiene should ignore everithing until the next letter starts
            } else if (lineType === 'line') {
                console.log(line.textContent);
                paragraph.push(line.textContent);
            } else if (lineType === 'line-number') {
                // skip line numbers
            } else {
                // unknown line indent -> probably right aligned text
                // does not detect indented text with left alignment
                console.log(line.textContent);
                paragraph.push(`<hi redention="#right">${line.textContent}</hi>`);
            }
        });
    });

    if (letter) {
        letters.push(letter);
    }

    console.log(letters);

    return letters;
}).then(function(letters) {
    console.log("Generating xml");

    // TODO: generate xml for letters
    letters.forEach(function(letter) {
        console.log(letter.paragraphs);
    });
}).catch(function (err) {
    console.log(err);
});
