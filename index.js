const fs = require("fs");
const Converter = require('pdftohtmljs');
const uuid = require('uuid-random');
const inlineCSS = require('inlinecss');
const moment = require('moment');
const jsdom = require("jsdom");
const {JSDOM} = jsdom;

if (process.argv.length < 3) {
    console.log("please provide a valid pdf path");
    process.exit(1);
}

let input = process.argv[2];

let path = 'output';
let outputFile = 'raw.html';

let pdf = Converter(input, outputFile, {
    bin: './php2htmlEX.sh',
});

// for testing only parse page 187 and 188
pdf.add_options([
    "--dest-dir " + path,
    "--fit-width 968",
    "-f 187",
    "-l 188",
    "--optimize-text 5",
    "--printing 0",
    "--embed-css 0",
    "--embed-font 0",
    "--embed-javascript 0",
]);

pdf.convert().then(function () {
    console.log("Generated raw html output [" + path + "/" + outputFile + "]");
    console.log("Loading generated html.");

    return new Promise(function (resolve, reject) {
        fs.readFile(path + "/" + outputFile, function (err, data) {
            if (err) {
                reject(err);
            } else {
                resolve(data.toString());
            }
        });
    });
}).then(function (html) {
    // Remove styles generated by pdf2htmlEX because they use invalid CSS syntax and cause inlineCSS to fail.
    console.log("Cleaning up generated html output");

    return html
        .replace('<link rel="stylesheet" href="base.min.css"/>', '')
        .replace('<link rel="stylesheet" href="fancy.min.css"/>', '')
        .replace('<link rel="stylesheet" href="document.css"/>', '<link rel="stylesheet" href="' + path + '/document.css"/>')
        .replace('<div id="sidebar">\n<div id="outline">\n</div>\n</div>\n', '')
        .replace('<div class="pi" data-data=\'{"ctm":[1.330000,0.000000,0.000000,1.330000,0.000000,0.000000]}\'></div>', '');
}).then(function (html) {
    console.log("Converting pdf2htmlEX generated css to inline css");

    return new Promise(function (resolve) {
        inlineCSS.inlineHtml(html, {
            removeAttributes: false,
        }, function (html) {
            resolve(html);
        });
    });
}).then(function (html) {
    console.log("Parsing generated html data");

    return new JSDOM(html).window.document;
}).then(function (document) {
    console.log("Analysing document");
    console.log("");

    let pages = document.querySelectorAll('body > div#page-container > div > div');

    let leftMap = {
        94: 'line-number',      // lno 10 or greater
        101: 'line-number',     // lno 5
        132: 'line',            // normal line indent
        155: 'new-paragraph',   // new paragraphs have a greater indent
    };

    // TODO:
    // use state machine (?)
    //  - current chapter
    //  - current letter
    //  - position inside letter (date, title, paragraph, apparatus, ...)
    //  - parse next line in document and decide based on current position

    // find chapters
    // find start/title of letter
    // extract date
    // extract opener
    // extract paragraphs and line breaks
    // drop line numbers
    // extract salute
    // extract signature
    // skip apparatuses and comments
    // processes next letter

    let letters = [];

    let letter, paragraph;

    pages.forEach(function (page) {
        page.childNodes.forEach(function (line, index) {
            if (index === 0) {
                console.log('');
                console.log('=========== new page ===========');
            }

            if (index < 2) {
                console.log('page header or number');
            }

            let left = Math.round(parseFloat(line.style.left));

            let lineType = leftMap[left];

            let normal = line.classList.contains('ff2');
            let italic = line.classList.contains('ff1');
            let bold = line.classList.contains('ff3');

            if (!(bold && lineType === 'line') && !letter) {
                return;
            }

            if (bold && lineType === 'line') {
                console.log(line.textContent);
                if (letter) {
                    letters.push(letter);
                }

                letter = {
                    title: line.textContent,
                    paragraphs: [],
                    apparatuses: null,
                    comments: null,
                };

                paragraph = [];
            } else if (lineType === 'new-paragraph') {
                if (paragraph.length > 0) {
                    letter.paragraphs.push(paragraph);
                }

                paragraph = [];

                paragraph.push(line.textContent);
                console.log(line.textContent);
            } else if (lineType === 'line' && italic) {
                // apparatuses or comment?
                // what if line is italic but part of the letter
            } else if (lineType === 'line') {
                console.log(line.textContent);
                paragraph.push(line.textContent);
            } else if (lineType === 'line-number') {
                // skip line numbers
            } else {
                // unknown line indent -> probably right aligned text
                console.log(line.textContent);
                paragraph.push(`<hi redention="#right">${line.textContent}</hi>`);
            }
        });
    });

    if (letter) {
        letters.push(letter);
    }

    console.log(letters);

    return letters;
}).then(function(letters) {
    console.log("Generating xml");

    // TODO: generate xml for letters
    letters.forEach(function(letter) {
        console.log(letter.paragraphs);
    });
}).catch(function (err) {
    console.log(err);
});
